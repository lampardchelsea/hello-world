/**
Refer to
https://leetcode.com/problems/remove-palindromic-subsequences/
You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string if it is generated by deleting some characters of a given string without 
changing its order. Note that a subsequence does not necessarily need to be contiguous.

A string is called palindrome if is one that reads the same backward as well as forward.

Example 1:
Input: s = "ababa"
Output: 1
Explanation: s is already a palindrome, so its entirety can be removed in a single step.

Example 2:
Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".

Example 3:
Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".

Constraints:
1 <= s.length <= 1000
s[i] is either 'a' or 'b'.
*/

// Solution 1: [Java] Use the Trick : the input string only consists of letters 'a' and 'b'!!
// Refer to
// https://leetcode.com/problems/remove-palindromic-subsequences/discuss/490352/Java-Use-the-Trick-%3A-the-input-string-only-consists-of-letters-'a'-and-'b'!!
/**
Quick Explanation: 
Notice there are 2 very important information (hints):
1. Remove the subsequence (not substring!). 
2. The input string only consists of letters 'a' and 'b'!
That means, there are 3 situations of this problem:
#1. String length equals 0 -> return 0;
#2. String itself is a Palindrome -> return 1; (because you can remove them all at once)
#3. Other cases, you can first remove all 'a' and then all 'b' or vice versa (first all 'b' then all 'a') -> return 2;

public int removePalindromeSub(String s) {
    if (s == null || s.length() == 0) {
        return 0; // This is the situation #1.
    }     
    int i = 0;
    int j = s.length() - 1;
    while (i < j) { // Checking the input string whether it is a Palindrome or not, by using the two pointers i and j.
        if (s.charAt(i) == s.charAt(j)) {
            i++;
            j--;
        } else {
            return 2; // The input string cannot pass the while-loop, so it is not a Palindrome. This is the situation #3.
        }
    }
    return 1; // The input string passes the while-loop, so it is a Palindrome, so we need 1 operation! This is the situation #2.
}

Time complexity: O(n), this is proportional to the length of input string.
Space complexity: O(1), since we do not use extra space to store the data.
*/
class Solution {
    public int removePalindromeSub(String s) {
        int i = 0;
        int j = s.length() - 1;
        while(i < j) {
            if(s.charAt(i) == s.charAt(j)) {
                i++;
                j--;
            } else {
                return 2;
            }
        }
        return 1;
    }
}

