/**
Explaination of why we can degrade 2D to 1D array and why we need loop backwards
Refer to
https://leetcode.com/problems/partition-equal-subset-sum/discuss/90592/01-knapsack-detailed-explanation
0/1 knapsack detailed explanation
This problem is essentially let us to find whether there are several numbers in a set which are able to sum to 
a specific value (in this problem, the value is sum/2).

Actually, this is a 0/1 knapsack problem, for each number, we can pick it or not. Let us assume dp[i][j] means 
whether the specific sum j can be gotten from the first i numbers. If we can pick such a series of numbers from 
0-i whose sum is j, dp[i][j] is true, otherwise it is false.

Base case: dp[0][0] is true; (zero number consists of sum 0 is true)

Transition function: For each number, if we don't pick it, dp[i][j] = dp[i-1][j], which means if the first i-1 
elements has made it to j, dp[i][j] would also make it to j (we can just ignore nums[i]). If we pick nums[i]. 
dp[i][j] = dp[i-1][j-nums[i]], which represents that j is composed of the current value nums[i] and the remaining 
composed of other previous numbers. Thus, the transition function is dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]

talking is cheap:

public boolean canPartition(int[] nums) {
    int sum = 0;
    
    for (int num : nums) {
        sum += num;
    }
    
    if ((sum & 1) == 1) {
        return false;
    }
    sum /= 2;

    int n = nums.length;
    boolean[][] dp = new boolean[n+1][sum+1];
    for (int i = 0; i < dp.length; i++) {
        Arrays.fill(dp[i], false);
    }
    
    dp[0][0] = true;
    
    for (int i = 1; i < n+1; i++) {
        dp[i][0] = true;
    }
    for (int j = 1; j < sum+1; j++) {
        dp[0][j] = false;
    }
    
    for (int i = 1; i < n+1; i++) {
        for (int j = 1; j < sum+1; j++) {
            dp[i][j] = dp[i-1][j];
            if (j >= nums[i-1]) {
                dp[i][j] = (dp[i][j] || dp[i-1][j-nums[i-1]]);
            }
        }
    }
   
    return dp[n][sum];
}

But can we optimize it? It seems that we cannot optimize it in time. But we can optimize in space. 
We currently use two dimensional array to solve it, but we can only use one dimensional array.

So the code becomes:

public boolean canPartition(int[] nums) {
    int sum = 0;
    
    for (int num : nums) {
        sum += num;
    }
    
    if ((sum & 1) == 1) {
        return false;
    }
    sum /= 2;
    
    int n = nums.length;
    boolean[] dp = new boolean[sum+1];
    Arrays.fill(dp, false);
    dp[0] = true;
    
    for (int num : nums) {
        for (int i = sum; i > 0; i--) {
            if (i >= num) {
                dp[i] = dp[i] || dp[i-num];
            }
        }
    }
    
    return dp[sum];
}
 
 
 
https://leetcode.com/problems/partition-equal-subset-sum/discuss/90592/01-knapsack-detailed-explanation/241664
Yes, the magic is observation from the induction rule/recurrence relation!
For this problem, the induction rule:
If not picking nums[i - 1], then dp[i][j] = dp[i-1][j]
if picking nums[i - 1], then dp[i][j] = dp[i - 1][j - nums[i - 1]]
You can see that if you point them out in the matrix, it will be like:

			  j
	. . . . . . . . . . . . 
	. . . . . . . . . . . .  
	. . ? . . ? . . . . . .  ?(left): dp[i - 1][j - nums[i]], ?(right): dp[i - 1][j]
i	. . . . . # . . . . . .  # dp[i][j]
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
 
Optimize to O(2*n): you can see that dp[i][j] only depends on previous row, so you can 
optimize the space by only using 2 rows instead of the matrix. Let's say array1 and array2. 
Every time you finish updating array2, array1 have no value, you can copy array2 to array1 
as the previous row of the next new row.
Optimize to O(n): you can also see that, the column indices of dp[i - 1][j - nums[i]] and 
dp[i - 1][j] are <= j. The conclusion you can get is: the elements of previous row whose 
column index is > j(i.e. dp[i - 1][j + 1 : n - 1]) will not affect the update of dp[i][j] 
since we will not touch them:

			  j
	. . . . . . . . . . . . 
	. . . . . . . . . . . .  
	. . ? . . ? x x x x x x  you will not touch x for dp[i][j]
i	. . . . . # . . . . . .  # dp[i][j]
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
	. . . . . . . . . . . . 
 
Thus if you merge array1 and array2 to a single array, if you update array backwards, 
all dependencies are not touched!

    (n represents new value, i.e. updated)
	. . ? . . ? n n n n n n n
              #  
However if you update forwards, dp[j - nums[i - 1]] is updated already, you cannot use it:

    (n represents new value, i.e. updated)
	n n n n n ? . . . . . .  where another ? goes? Oops, it is overriden, we lost it :(
              #  
Conclusion:
So the rule is that observe the positions of current element and its dependencies in the matrix. 
Mostly if current elements depends on the elements in previous row(most frequent case)/columns, 
you can optimize the space.
*/
